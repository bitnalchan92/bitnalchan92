## 14장. 가상 테이블인 뷰

2. **<탄탄히 다지기> 1.번에서 작성한 뷰에 다음과 같은 결과를 얻을 수 있도록 컬럼 별칭을 추가하여 뷰를 변경해 봅시다. ( 힌트 : OR REPLACE 옵션 사용 )**

CREATE OR REPLACE VIEW EMP_VIEW20
AS
SELECT EMPNO AS EMP_NO, ENAME AS EMP_NAME, DEPTNO AS DEPT_NO, MGR AS MANAGER, SAL
FROM EMP_COPY
WHERE DEPTNO = 20;



3. **인라인뷰를 사용하여 급여를 많이 받는 순서대로 3명만 출력하는 뷰(SAL_TOP3_VIEW)를 작성하시오.**

CREATE OR REPLACE VIEW SAL_TOP3_VIEW
AS
SELECT ROWNUM AS RANKING, EMPNO, ENAME, SAL
FROM (SELECT EMPNO, ENAME, SAL FROM EMP ORDER BY SAL DESC)
WHERE ROWNUM <= 3;



4. **4번을 참고하여 2위와 3위만 출력하도록 해보세요.**

SELECT *
FROM SAL_TOP3_VIEW
WHERE RANKING BETWEEN 2 AND 3;



---



## 15장. 시퀀스

1. 

CREATE TABLE DEPT_EXAMPLE
(
    DEPTNO NUMBER(4) PRIMARY KEY,
    DNAME  VARCHAR2(15),
    LOC    VARCHAR2(15)
);



**1.1 DEPTNO 컬럼에 유일한 값을 가질 수 있도록 시퀀스 객체 생성(시퀀스 이름 : DEPT_EXAMPLE_SEQ) 해 봅시다.**

CREATE SEQUENCE DEPT_EXAMPLE_SEQ
START WITH 10
INCREMENT BY 10;



**1.2 새로운 로우를 추가할 때마다 시퀀스에 의해서 다음과 같이 부서 번호가 자동으로 부여되도록 해 봅시다.**

INSERT INTO DEPT_EXAMPLE
VALUES (DEPT_EXAMPLE_SEQ.NEXTVAL, '인사과', '서울');
INSERT INTO DEPT_EXAMPLE
VALUES (DEPT_EXAMPLE_SEQ.NEXTVAL, '경리과', '서울');
INSERT INTO DEPT_EXAMPLE
VALUES (DEPT_EXAMPLE_SEQ.NEXTVAL, '총무과', '대전');
INSERT INTO DEPT_EXAMPLE
VALUES (DEPT_EXAMPLE_SEQ.NEXTVAL, '기술팀', '인천');



2. **시퀀스값 순환하기(DEPT_SEQ)**

CREATE SEQUENCE DEPT_SEQ
    START WITH 10
    INCREMENT BY 10
    MAXVALUE 40
    MINVALUE 10
    CYCLE
    NOCACHE; -- CACHE 3 로 하여 오류 해결할 수 있음

-- CACHE의 크기가 시퀀스의 범위 ( MAXVALUE - MINVALUE )보다 클때 ORA-04013 발생 => 해결방법은 NOCACHE를 사용하거나, CACHE값을 줄이는 방법이 있고, NOCACHE를 사용하는 경우, 시퀀스 번호의 연속성 보장과, 값 손실 방지의 이점이 있다고는 하는데 개발시 성능과, 일관성 사이에서 고려해볼 필요가 있음

-- CACHE가 생략되는 경우, CACHE는 기본값이 20이 설정되서 on cycle과 비교합니다. 10 -> 20 -> 30 -> 40의 경우 one cycle이 4가 되고 이보다 작은 수 즉, 2와 3만 허용합니다. (1은 허용하지 않음) 결론적으로 CYCLE을 갖는 경우 CACHE는 1보다 크고 ONE CYCLE보다 작은 수를 설정해야 합니다.



3. **MAX(EMPNO)를 이용해서 사원번호 만들어 보세요**

CREATE TABLE EMP_MAX(
	EMPNO NUMBER(2) PRIMARY KEY
      , ENAME VARCHAR2(12)
);

INSERT INTO EMP_MAX
VALUES ((SELECT NVL(MAX(EMPNO), 0) + 1 FROM EMP_MAX), 'AAA');

INSERT INTO EMP_MAX
VALUES ((SELECT NVL(MAX(EMPNO), 0) + 1 FROM EMP_MAX), 'BBB');



---



## 16장. 인덱스

1. **( )는 조회의 성능을 향상시키는 객체이다.**

인덱스



2. **EMP01 테이블의 직급 컬럼을 인덱스로 설정하되 인덱스 이름을 IDX_EMP01_JOB로 줍시다.**

CREATE INDEX IDX_EMP01_JOB
    ON EMP01 (JOB);



---



1. **MBC라는 사용자를 생성하되 암호는 PASS로 합니다. 생성된 사용자에 기본적인 권한을 부여하지 않으면 데이터베이스에 로그인 불가능하므로 CREATE SESSION 권한을 MBC 사용자에게 부여하시오.**

-- sys 계정에서...

CREATE USER MBC IDENTIFIED BY PASS;
GRANT CREATE SESSION TO MBC;



2. **scott 계정에서 만든 dept 테이블과 같은 구조의 테이블을 만들어보세요.** 

-- sys 계정에서...

GRANT CREATE TABLE TO MBC;
ALTER USER MBC QUOTA 2M ON SYSTEM;



-- MBC 계정에서... ( conn MBC/PASS )

CREATE TABLE DEPT (	
	DEPTNO NUMBER(2) PRIMARY KEY,
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13)
);



---



## 15장 문제2 풀이

1. 

CREATE TABLE GRADECARD
(
    NO   NUMBER(3) PRIMARY KEY,
    NAME VARCHAR2(20) NOT NULL,
    KOR  NUMBER(3)    NOT NULL CHECK ( KOR BETWEEN 0 AND 100 ),
    ENG  NUMBER(3)    NOT NULL CHECK ( ENG BETWEEN 0 AND 100 ),
    MAT  NUMBER(3)    NOT NULL CHECK ( MAT BETWEEN 0 AND 100 ),
    TOT  NUMBER(3) DEFAULT 0
);



2. 

-- SEQUENCE 만들기

CREATE SEQUENCE GRADECARD_NO_SEQ
    START WITH 1
    INCREMENT BY 1;



-- 데이터 넣기 

insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, '자바', 90, 100, 67);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, '오라클', 96, 94, 89);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, 'HTML5', 67, 79, 56);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, 'Jquery', 87, 88, 72);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, 'JSP', 48, 65, 41);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, 'JAVASCRIPT', 65, 97, 51);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, '스프링', 79, 58, 61);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, 'CSS3', 88, 57, 51);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, '마이바티스', 60, 99, 65);
insert into GRADECARD (NO, NAME, KOR, ENG, MAT)
values (GRADECARD_NO_SEQ.nextval, 'XML', 95, 67, 45);



3. 

UPDATE GRADECARD
SET TOT = KOR + ENG + MAT;



4. 

SELECT NO 번호, NAME 이름
     , KOR 국어, ENG 영어, MAT 수학, TOT 총계
     , RANK() OVER ( ORDER BY TOT DESC ) 등수
FROM GRADECARD;

```
SELECT S.*, ROWNUM 등수
FROM (SELECT NO "번호", NAME "이름", KOR "국어", ENG "영어", MAT "수학", TOT "총계"
      FROM GRADECARD
      ORDER BY TOT DESC) S;
```



5. 

SELECT *
FROM (SELECT NO                                   번호
           , NAME                                 이름
           , KOR                                  국어
           , ENG                                  영어
           , MAT                                  수학
           , TOT                                  총계
           , RANK() OVER ( ORDER BY TOT DESC ) as 등수
      FROM GRADECARD)
WHERE 등수 = 5;



6. 

SELECT *
FROM (SELECT NO                                   번호
           , NAME                                 이름
           , KOR                                  국어
           , ENG                                  영어
           , MAT                                  수학
           , TOT                                  총계
           , RANK() OVER ( ORDER BY TOT DESC ) as 등수
      FROM GRADECARD)
WHERE 등수 BETWEEN 4 AND 7;



7. 

CREATE TABLE GRADE
(
    LOWSCORE NUMBER(3),
    HISCORE  NUMBER(3),
    GRADE    VARCHAR2(4)
);

INSERT INTO GRADE VALUES (0, 59, 'F');
INSERT INTO GRADE VALUES (60, 64, 'D0');
INSERT INTO GRADE VALUES (65, 69, 'D+');
INSERT INTO GRADE VALUES (70, 74, 'C0');
INSERT INTO GRADE VALUES (75, 79, 'C+');
INSERT INTO GRADE VALUES (80, 84, 'B0');
INSERT INTO GRADE VALUES (85, 89, 'B+');
INSERT INTO GRADE VALUES (90, 94, 'A0');
INSERT INTO GRADE VALUES (95, 100, 'A+');



8. 

SELECT NO,
       NAME,
       KOR,
       ENG,
       MAT,
       TOT,
       ROUND(TOT / 3) 평균,
       G.GRADE 등급
FROM GRADECARD GC
         INNER JOIN GRADE G ON ROUND(GC.TOT / 3) BETWEEN G.LOWSCORE AND G.HISCORE
ORDER BY TOT;



9. 

ALTER TABLE GRADECARD
    ADD (AVG NUMBER(3) CHECK (AVG BETWEEN 0 AND 100), GRADE VARCHAR2(4));



10. 

```markdown
연관 서브쿼리 
- 서브쿼리가 메인쿼리의 컬럼을 가지고 있는 형태의 서브쿼리 
- 행마다 서브쿼리가 반복 실행 
  (1) 메인 쿼리가 테이블의 각 행을 읽습니다.
  (2) 서브쿼리는 메인 쿼리의 특정 행의 데이터를 사용하여 서브쿼리를 실행합니다.
  (3) 서브쿼리의 결과는 메인쿼리로 반환되어, 메인쿼리의 조건을 결정하거나 값을 반환하는데 사용됩니다.
- 인라인뷰에서는 사용할 수 없습니다.
```

UPDATE GRADECARD GC
SET AVG   = ROUND(TOT / 3),
    GRADE = (SELECT G.GRADE
             FROM GRADECARD
                      INNER JOIN GRADE G ON ROUND(TOT / 3) BETWEEN G.LOWSCORE AND G.HISCORE
             WHERE GC.NAME = NAME);

UPDATE GRADECARD GC
SET AVG   = ROUND(TOT / 3),
    GRADE = (SELECT GRADE
             FROM GRADE
             WHERE ROUND(TOT / 3) BETWEEN LOWSCORE AND HISCORE);



11. 

SELECT TABLE_NAME                                                                            AS 자식테이블
     , COLUMN_NAME                                                                           AS 외래키
     , (SELECT TABLE_NAME FROM USER_CONS_COLUMNS WHERE CONSTRAINT_NAME = R_CONSTRAINT_NAME)  AS 부모테이블
     , (SELECT COLUMN_NAME FROM USER_CONS_COLUMNS WHERE CONSTRAINT_NAME = R_CONSTRAINT_NAME) AS 부모키
FROM USER_CONSTRAINTS
         NATURAL JOIN USER_CONS_COLUMNS
WHERE R_CONSTRAINT_NAME IS NOT NULL
  AND (TABLE_NAME LIKE 'EMP%' OR TABLE_NAME LIKE 'CHILD%');
